<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    .box {
        &:popover-open {
            background-color: red;

            @initial {}
        }
    }
</style>

<body>

</body>

</html>
<script>
    // 浏览器的渲染机制
    // 第一步 解析
    // 浏览器会解析html 解析过程中遇到css解析css 遇到js就执行js
    // 为了提高效率  主线程会开启一个预解析的线程 率先下载 html外部引用的css 和 js
    // 如果解析到 link 标签  外部的css还没有下载解析好  主线程不会等待而是继续解析后续html
    // 因为 下载和解析外部的css 是在预解析线程中进行的  这就是为什么css不会阻塞html解析的原因
    // 如果解析的script 标签 则会停止解析html 转而等下js下载完毕 并将js代码解析执行完毕后 再继续解析html
    // 因为 js中可能存在修改或者变动dom的操作  所以dom数的生成必须暂停  这就是为什么js会阻塞html解析的原因
    // 解析完成后 会得到 一个Dom树 一个CssOm树  浏览的默认样式、内部样式、行内样式、外部样式都包含在CssOm树中

    // 第二步 样式计算
    // 主线程会遍历Dom树的所有节点 给每个Dom节点计算出最终样式
    // 在这个过程中  很多预设值会转换成绝对值   相对单位会转换为绝对单位
    // 这一步完成后 会得到一个带有样式的Dom树 render渲染树

    // 第三步 布局
    // 主线程遍历dom树 给dom节点设置几何信息 (位置 尺寸 )
    // Dom树和布局Layout 不一定是一一对应的
    // 因为有些元素可能是display:none的节点没有布局信息 不会出现在最终的布局中
    // 或者:before :after 这种伪类元素  伪元素节点本身在dom树中不存在 但是他们拥有几何信息 所以会生成在布局树中
    // 还有匿名行盒  匿名块盒 行盒和块盒不能相邻 文本内容必须在行盒中

    // 第四步 分层
    // 主线程会使用一套复杂的策略 对布局树进行分层
    // 分层的好处是将来某一层改变后 仅对该层进行后续处理  从而提升效率
    // 滚动条 堆叠上下文 transform opacity 或多或少会影响浏览器的分层  css属性will-change 更大程度影响分层结果

    // 第五步 绘制
    // 为每一层都生成如何绘制的指令
    // 主线程为每个层单纯生成绘制指令集 用于描述这层的内容如何画出来
    // 主线程将每个层的绘制信息交给合成线程完成

    // 第六部 分块
    // 合成线程首先对每个图层进行分块 将他们划分成更多的小区域
    // 他会启动多个线程来完成分块工作
    // 渲染主线程执行完毕

    // 第七步 光栅化
    // 合成线程将将块信息交给GPU进程
    // GPU进行光栅化就是把块转换成位图,最后交给合成线程
    // 优先处理靠近视口的块

    // 第八步 画
    // 合成线程拿到每个层的 每个块的位图后 会生成一个个的quad 指引信息
    // 指引信息会标识出 每个位图应该会在屏幕的那些位置 以及考虑到旋转、变形
    // transform 发生在合成线程中 与渲染主线程无关  所以只就是transform 效率高的原因
    // 合成线程将quad教程GPU进程 GPU进程将进行系统调用 提交给GPU硬件  完成最终的屏幕成像。


    // 重排
    // 重排的本质就是重新计算布局树
    // 当进行了影响布局树的操作后 需要重新计算布局树  会引发Layout 
    // 修改dom的集合信息 width height marigin padding font-size

    // 重绘
    // 重新根据分层信息计算了绘制指令
    // 更改了元素的可见信息 就会触发重绘
    // 元素的几何信息是可见信息 所以重排必定进行重绘


</script>